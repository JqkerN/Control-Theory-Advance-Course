close all; clear all; clc;


%% 3.1.1
disp('<strong>Task 3.1.1</strong>')
s = tf('s');
sysmp = minreal(minphase);
G = minreal(sysmp.C*(s*eye(size(sysmp.A)) - sysmp.A)^(-1)*sysmp.B + sysmp.D);

size(G)
disp('Poles G(1,1):')
disp(pole(G(1,1)))
disp('Poles G(1,2):')
disp(pole(G(1,2)))
disp('Poles G(2,1):')
disp(pole(G(2,1)))
disp('Poles G(2,2):')
disp(pole(G(2,2)))
disp('Zeros G(1,1):')
disp(tzero(G(1,1)))
disp('Zeros G(1,2):')
disp(tzero(G(1,2)))
disp('Zeros G(2,1):')
disp(tzero(G(2,1)))
disp('Zeros G(2,2):')
disp(tzero(G(2,2)))

%% 3.1.2
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.1.2</strong>')

disp('Poles G:')
disp(pole(G))
disp('Zeros G:')
disp(tzero(G))

%% 3.1.3
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.1.3</strong>')

disp('plot figure 313: singular values')
figure(313)
sigma(G); title('3.1.3 singular values'); grid on;

%% 3.1.4
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.1.4</strong>')

RGA = G.*inv(G)';
disp('RGA: ')
disp(evalfr(RGA,0))

%% 3.1.5
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.1.5</strong>')

disp('plot figure 315: G(*,*) step response')
figure(315)
step(G); title('3.1.5 Step response'); grid on;
disp('Ans. One could notice that they are coupled. Which matches with the matrix from 3.1.5')

%% 3.1.6
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.1.6</strong>')
s = tf('s');
sysNONmp = minreal(nonminphase);
G_NON = minreal(sysNONmp.C*(s*eye(size(sysNONmp.A)) - sysNONmp.A)^(-1)*sysNONmp.B + sysNONmp.D);

size(G_NON)
disp('Poles G_NON(1,1):')
disp(pole(G_NON(1,1)))
disp('Poles G_NON(1,2):')
disp(pole(G_NON(1,2)))
disp('Poles G_NON(2,1):')
disp(pole(G_NON(2,1)))
disp('Poles G_NON(2,2):')
disp(pole(G_NON(2,2)))
disp('Zeros G_NON(1,1):')
disp(tzero(G_NON(1,1)))
disp('Zeros G_NON(1,2):')
disp(tzero(G_NON(1,2)))
disp('Zeros G_NON(2,1):')
disp(tzero(G_NON(2,1)))
disp('Zeros G_NON(2,2):')
disp(tzero(G_NON(2,2)))


RGA_NON = G_NON.*inv(G_NON)';
disp('RGA: ')
disp(evalfr(RGA_NON,0))

disp('plot figure 3161: singular values')
figure(3161)
sigma(G_NON); title('3.1.6(1) singular values'); grid on;

disp('plot figure 3162: G(*,*) step response')
figure(3162)
step(G_NON); title('3.1.6(2) Step response'); grid on;

%% 3.2.1
disp(' ')
disp('<strong>---------------------------------------------------</strong>')
disp('<strong>Task 3.2.1</strong>')

%---------------------------
%       VARIABLES:
phi_mp = pi/3; % Intended phase margin (minimum phase case!)
wc_mp = 0.1;   % rad/s crossover frequency  (minimum phase case!)
%---------------------------

Design a decentralized controller by pairing inputs and outputs according to the RGA analysis. 
The intended phase margin is ?m = ?/3 and the crossover frequency ?c is 0.1 rad/s for the minimum phase case and 0.02 rad/s for the
non-minimum phase case. (To make sure that the problem is correctly solved, investigate the Bode diagram of L.)
